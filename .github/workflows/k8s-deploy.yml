name: Kubernetes Deployment

on:
  push:
    branches: [ main ]
    paths:
      - 'kubernetes/**'
      - '.github/workflows/k8s-deploy.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

env:
  AWS_REGION: 'us-west-2'

jobs:
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Install Helm
      uses: azure/setup-helm@v3
      with:
        version: 'v3.13.0'

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name scalable-infra-${{ github.event.inputs.environment || 'dev' }}
        kubectl config set-context --current --namespace=scalable-app

    - name: Deploy Kubernetes manifests
      run: |
        kubectl apply -f kubernetes/namespaces.yaml
        kubectl apply -f kubernetes/manifests/
        kubectl rollout status deployment/backend-service -n scalable-app --timeout=300s
        kubectl rollout status deployment/frontend-service -n scalable-app --timeout=300s
        kubectl rollout status deployment/api-gateway-service -n scalable-app --timeout=300s

    - name: Deploy with Helm
      run: |
        helm upgrade --install scalable-app kubernetes/helm-charts/scalable-app \
          --namespace scalable-app \
          --create-namespace \
          --set image.tag=${{ github.sha }} \
          --set database.host=${{ secrets.DB_HOST }} \
          --set database.password=${{ secrets.DB_PASSWORD }} \
          --wait --timeout=10m

    - name: Run health checks
      run: |
        kubectl get pods -n scalable-app
        kubectl get services -n scalable-app
        kubectl get ingress -n scalable-app
        
        # Wait for pods to be ready
        kubectl wait --for=condition=ready pod -l app=backend-service -n scalable-app --timeout=300s
        kubectl wait --for=condition=ready pod -l app=frontend-service -n scalable-app --timeout=300s
        kubectl wait --for=condition=ready pod -l app=api-gateway-service -n scalable-app --timeout=300s

    - name: Run smoke tests
      run: |
        # Get service endpoints
        BACKEND_URL=$(kubectl get service backend-service -n scalable-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo "backend-service.scalable-app.svc.cluster.local")
        FRONTEND_URL=$(kubectl get service frontend-service -n scalable-app -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || echo "frontend-service.scalable-app.svc.cluster.local")
        
        # Basic health checks
        kubectl run test-pod --image=curlimages/curl --rm -i --restart=Never -- \
          curl -f http://backend-service.scalable-app.svc.cluster.local:80/health || echo "Backend health check failed"
        
        kubectl run test-pod --image=curlimages/curl --rm -i --restart=Never -- \
          curl -f http://frontend-service.scalable-app.svc.cluster.local:80/ || echo "Frontend health check failed"

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "✅ Deployment to ${{ github.event.inputs.environment || 'dev' }} environment successful!"
        else
          echo "❌ Deployment to ${{ github.event.inputs.environment || 'dev' }} environment failed!"
        fi
